data Surreal = Surreal [Surreal] [Surreal]

left :: Surreal -> [Surreal]
left (Surreal xs _) = xs

right :: Surreal -> [Surreal]
right (Surreal _ ys) = ys

(<=) :: Surreal -> Surreal -> Bool
a@(Surreal aL _) <= b@(Surreal _ bR) =
    and (not . (<= b) <$> aL) && and (not . (a <=) <$> bR)

(>=) :: Surreal -> Surreal -> Bool
a@(Surreal _ aR) >= b@(Surreal bL _) =
    and (not . (b >=) <$> aR) && and (not . (>= a) <$> bL)

(>) :: Surreal -> Surreal -> Bool
a@(Surreal aL _) > b@(Surreal _ bR) =
    or (not . (b >) <$> aL) || or (not . (a >) <$> bR)

(<) :: Surreal -> Surreal -> Bool
a@(Surreal _ aR) < b@(Surreal bL _) =
    or (not . (b <) <$> aL) || or (not . (< a) <$> bL)

0 :: Surreal
0 = Surreal [] []

1 :: Surreal
1 = Surreal [Surreal [] []] []

-1 :: Surreal
-1 = Surreal [] [Surreal [] []]

--for convienience, I'm going to talk about the surreal without using the
--data constructor. So, for instance, [] [] is 0 and [[] []] [] is 1 and [] [[] []] is -1

0 = [] []
1 = [[] []] []
-1 = [] [[] []]
* = [[] []] [[] []] --Not a number
2 = {{

On day 0, each L and R can only be the empty set,
    so the only number that can exist is [] []. We call this number zero.
On day 1, each L and R can be either the empty set or the set containing our
    previous number 0,
    let C1 be all the candidates for L and R for constructed in this cycle
    C1 = [{}, {[] []}]
    so the N1 are [[L], [R] | L <- C1, R <- C1]
    Since C1 has length 2, there are 4 different games for this cycle,
    Note that in this construction, C0 is a subset of C1, because [] [] can be
    generated by N1
    N1 has four games -1 0 1 and *
On day 2, each L and R can be the power set of C1
    Generally speaking, Ci is the power set of N(i-1)
    So C0 = [{}]
    C1 = [{}, {0}]
    C2 =
        [ {}
        , {-1}, {0}, {1}, {*}
        , {-1, 0}, {-1, 1}, {-1, *}, {0, 1}, {0, *}, {1, *}
        , {-1, 0, 1}, {-1, 0, *}, {-1, 1, *}, {0, 1, *}
        , {-1, 0, 1, *}
        ]
    Since C2 has 16 elements, that means there are 256 possible games of the form
    [[l] [r] | l <- C2, r <- C2]
    Obviously, it would be absurd to expect to write out every one of them and assign
    names to each one. In this case it becomes much easier to write out
    facts about the equivilence class defined by = and pick a "characteristic game"
    for any game in that equivilence class.
    At this juncture, though, I would like to go back to a discussion of numbers
    and not games.

So starting again from the top.
Let Gi be "Generation i".
Ci is the set of all candidates for L and R for a number in Gi,
    each member of Ci is always a set of numbers (a member of Ci can be the empty set)
Ni is the list of all numbers in {[l] [r] | l <- Ci, r <- Ci}
G0
    C0 = {{}}
    0 = {L|R} where L = {} and R = {}
    N0 = {0}
G1
    C1 = {{}, {0}}
    {L|R} where L = {} and R = {} is already a number that we call 0
    1 = {L|R} where L = {0} and R = {}
    -1 = {L|R} where L = {} and R = {0}
    {L|R} where L = {0} and R = {0} is not a number, since there is a member of L that is >= a member of R
    N1 = {1, 0, -1}
G2
    C2 = {{}, {1}, {0}, {-1}, {1,0}, {1, -1}, {0, -1}, {1, 0, -1}}
    At this point, we know the answer of
        N2 = {2, 1, 1/2, 0, -1/2, -1, -2}
        but we would rather not arrive at this by constructing all 64 possiblites
        of C2 x C2 and determining which ones are numbers and which ones fall
        into equivelence classes and would rather be able to figure out
        what all the numbers are by coming with with some general rules
        about how to construct the characteristic members of each equivilence class
        in N2
    Lets write down a lemma:
        For every l in L, l < {L|R}
        For every r in R, r > {L|R}
        Lets prove the first one. Let's pick an L and call it l.
        In order to show l < {L|R}, we need to show that
        There exists an lR <= {L|R} or there exists an L >= l
        We can show that there exists an L >= l, namely l, so we have l >= l
        The proof for r > {L|R} is similar as there is an R <= r, namely r
    Lets write down a theorem:
        If x = {L|R}, and let y be a number less than or equal to some member of L
        {L union {y}|R} = {L|R}
    Likewise
        If x = {L|R} and let y be a number greater than or equal to some member of R
        {L|R union {y}} = {L|R} where R2 = R union {y}
    Proof
        Lets first write out some definitions
            a <= b iff every aL < b and every bR > a
            a >= b iff every aR > b and every bL < a
            a < b iff there is an aR <= b or there is an bL >= a
            a > b iff there is an al >= b or there is an bR <= a
            a = b iff every aL < b, every aR > b, every bL < a, every bR > a
        So say x = {L|R} and y is a number such that y <= l for some L
        Say L' = L union {y}
        In order to show that {L'|R} = {L|R}, we need to show that
        every L' < {L|R}, every R > {L|R}, every L < {L'|R} and every R > {L'|R}
        every L' < {L|R}
            if l is a member of L, then l < {L|R} from our lemma above
            if l is y, we know that there is another L l' where y <= l', and
            since y <= l' and l' < {L|R} (from our lemma) y < {L|R} due to associativity
            NOTE: if we lift the restriction that y <= l for some L, this is the case that fails.
            The other cases do not depend on y
        every R > {L|R}
            this holds diretly from the lemma
        every L < {L'|R}
            call l a member of L
            this is true when there is an lR <= {L'|R} or there is an L' >= l
            choose l (as an element of L union {y}) as a particular L'
            (we know that l is in L' because of the way union works), and we have l >= l
        every R > {L'| R}
            call r a member of R
            this is true when there is an rL >= {L'|R} or there is an R <= r
            choose r as a particular R and and we have r >= r
    There is a similar proof that {L|R'} = {L|R}

        xL = L
        xR = R
        x'L = L union {y}
        x'R = R

        For the first predicate, this holds true trivially for all but x'L = y,
        in that case, since there is an x'L where y <= x'L from our assumption, x'L
        must be < x and if a <= b and b < c then a < c by associativity

0 = {|}
1 = {{|}|}
-1 = {|{|}}
2 = {{{|}|}|}
-2 = {|{|{|}}}

aL = {}
aR = {0}
bL = {0}
bR = {}
a < b because 0 (as an element of aR) <= b ({bL|bR}). This <= statement holds vacuously (for every element in 0L (there is none) and for every element in bR (there is none))

--(<=) :: Surreal -> Surreal -> Bool
--(<=) a@(Surreal aL _) b@(Surreal _ bR) = (&&) --(not ((<=) aL b)) (not ((<=) a bR))
--    (foldr ((&&) $ not . (<= b)) True aL)
--    (foldr ((&&) $ not . (a <=)) True bR)


--and (not . (<= b) <$> aL)
--and (not . (a <=) <$> bR)
--and (map (\al -> not ((<=) al b)) aL)
--
--(foldr (\al acc -> acc && not ((<=) al b)) True aL)


