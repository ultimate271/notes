# June approaches!

Today marks the last day that I plan to have a felony outstanding on my record.

Since I have been arrested, I have learned a great deal about life, the
universe, and everything, and I feel as though I am ready for this step in my
life.

Still, I feel somehow apprehensive as tomorrow approaches. I am very anxious,
and entirely nervous. I feel like there is a monkey on my back, and it's like a
chimpanzee or something, so it's not the most heavy, but it's sleeping, and
tomorrow I'm going to take the monkey to the court place, take it off of my
back, wake it up, and hand it to them.

I don't want this monkey anymore. I want everything shreded, I want everything
burned. I want to see it with my eyes. I want to watch the papers go up in
smoke and flames. I want to watch the person write the delete records in the
database. I want a copy of the http request to ensure that it did indeed
execute and confirm the desired execution plan.

At the end of the day though, as far as getting arrested is concerned, things
turned out all right. I am alive, I am intact, I am unraped, and I understand
the dangers, pitfalls, and downfalls of our justice system now.

I talked to Takashi yesterday, and he and I connected on a deeper level than I
think he and I have before. Now that two years have gone by, and Ciara is a
part of my past now, I can safely say that I am comfortable with where I am
right now in life, and that I truly feel that this represents a new beginning
for me.

Still, though, I am not eating. I am anxious, and I am exhausted of thinking
about court nonsense.

## Agnostic Musings

So I mentioned agnosticsm over the phone, and I want to say what I think
agnosticsm is, and what it is not.

Agnosticism is an umbrella term to me which refers to all of those aspcets of
life which are "agnostic" to particular methods.

The first example that comes to mind is an example from Computer Science.

When running security protocols on computer programs to ensure that the meet
the requirements of what you would like them to, there are two approaches. The
first approach is what is called "Static Analysis" which is where you have your
compiler lay out it's parse tree, and from there you prune some of the nodes
according to some rather clever algorithms, and then from there your source
code is written in a much more neat and coherent way.

The second method of security verification is what is called "Compiler
Agnostic". The way this method works is, instead of looking at the source code
(which depends on which programming language the program was written in),
instead we look at the output of the compiler, which is, in most cases, machine
code. From there, we can take any executable, regardless of which language it
was written in, and run security protocols on it to ensure that it doesn't
break anything when we run it on our nuclear control system (or whatever system
we are so concerned about security for).

So the first approach has the advantage that more information is known.
However, it turns out that, when you get very good at the agnostic approach to
programing, rather than a specailized or dogmatic approach to programming, you
start to realize that the agnostic approach is vastly superior to the dogmatic
one that it's almost absurd to think that anyone would ever "specialize" in any
one language.

In fact, I would say that the agnostic approach to programming is so much
superior than the dogmatic approach, not only from a security perspective, but
also just from a general Computer Science principles perspective, that I would
say even the most casual of enthusiasts should always start by dipping their
feet wet in at least three or four languages before honing in on a first one to
begin their first journey.

To make a statement like "C++ can do everything I need it to, so I don't need
to learn any other language" is so patently absurd to my ears, that when I hear
a programmer say something like that, I understand that they are in the
"unenlightened" category when it comes to how they approach computer code. I
would much rather hear a programmer say something like "I learned C++ first, so
it holds a special place in my heart, but I use C# now because it fits my
purposes better".

As a final word, I want to make a comment about Yin and Yang, because we talked
about that as well. In this example, the Dogma is the Yang and the Agnosticism
is the Yin. I feel, in our excessively Abrahamic world, where Islam, Cristianity, and
Judiasm span the majority of the westeren world, some eastern practice is what
we need to counteract the over attention to order that we seem obsessed with as
a people right now. In computer science, there are many programers that seemed
obsessed with saying "I am a Java programmer" or "I am a Ruby programmer" or "I
am a [insert flavor of the month language here] programmer", and I think that
this mentality is toxic towards not only the field of computer science as a
whole, but also towards how we approach challenging subjects.

A much better approach is to incorporate the Yin. You say, "I want to
specialize in one language for a particualar project, but I understand that
each programing language is like a tool, and that I might have to use multiple
languages and multiple tools to get the job done."

This way, you have an ordered system (Yang) which is good, but at the same
time, you have enough chaos (Yin) to keep your system robust.

Then, when you work on your project, you start with the Yang (you write the
core of your project in one particular language), then you incorperate the Yin
(you write extentsions to your project in other languages and link in other
tools as neccesary), and finally you integrate both at the same time (which
represents the final phases of the project, where it's all put together, and
you are ironing out that last 20 % which takes 80 % of the time).

So that is how I like to incorperate eastern philosophy into my programming
practice.

Of course, there are many other ways of understanding what Computer Science and
programming mean, but just for the sake of this short little essay, I will keep
it brief.

Let me know your thoughts.

- Brett "Gerald Orbweaver" Webster



So I mentioned agnosticism over the phone, and I want to say what I think agnosticism is, and what it is not.

Agnosticism is an umbrella term to me which refers to all of those aspects of life which are "agnostic" to particular methods.

The first example that comes to mind is an example from Computer Science.

When running security protocols on computer programs to ensure that the meet the requirements of what you would like them to do, there are two approaches. The first approach is what is called "Static Analysis" which is where you have your compiler lay out it's parse tree, and from there you prune some of the nodes according to some rather clever algorithms, and then from there your source code is written in a much more neat and coherent way.

The second method of security verification is what is called "Compiler Agnostic Security Verification". The way this method works is, instead of looking at the source code (which depends on which programming language the program was written in), instead we look at the output of the compiler, which is, in most cases, machine code. From there, we can take any executable, regardless of which language it was written in, and run security protocols on it to ensure that it doesn't break anything when we run it on our nuclear control system (or whatever system we are so concerned about security for).

So the first approach has the advantage that more information is known.  However, it turns out that, when you get very good at the agnostic approach to programing, rather than a specialized or dogmatic approach to programming, you start to realize that the agnostic approach is vastly superior to the dogmatic one that it's almost absurd to think that anyone would ever "specialize" in any one language.

In fact, I would say that the agnostic approach to programming is so much superior than the dogmatic approach, not only from a security perspective, but also just from a general Computer Science principles perspective, that I would say even the most casual of enthusiasts should always start by dipping their feet wet in at least three or four languages before honing in on a first one to begin their first journey.

To make a statement like "C++ can do everything I need it to, so I don't need to learn any other language" is so patently absurd to my ears, that when I hear a programmer say something like that, I understand that they are in the "unenlightened" category when it comes to how they approach computer code. I would much rather hear a programmer say something like "I learned C++ first, so it holds a special place in my heart, but I use C# now because it fits my purposes better".

As a final word, I want to make a comment about Yin and Yang, because we talked about that as well. In this example, the Dogma is the Yang and the Agnosticism is the Yin. I feel, in our excessively Abrahamic world, where Islam, Christianity, and Judaism span the majority of the Western world, some Eastern practice is what we need to counteract the over attention to Order that we seem obsessed with as a people right now. In computer science, there are many programmers that seemed obsessed with saying "I am a Java programmer" or "I am a Ruby programmer" or "I am a [insert flavor of the month language here] programmer", and I think that this mentality is toxic towards not only the field of computer science as a whole, but also towards how we approach challenging subjects.

A much better approach is to incorporate the Yang, then the Yin, then both. You say, "I want to specialize in one language for a particular project, but I understand that each programing language is like a tool, and that I might have to use multiple languages and multiple tools to get the job done."

This way, you have an ordered system (Yang) which is good, but at the same time, you have enough chaos (Yin) to keep your system robust.

Then, when you work on your project, you start with the Yang (you write the core of your project in one particular language), then you incorporate the Yin (you write extensions to your project in other languages and link in other tools as necessary), and finally you integrate both at the same time (which represents the final phases of the project, where it's all put together, and you are ironing out that last 20 % which takes 80 % of the time).

So that is how I like to incorporate eastern philosophy into my programming practice.

Of course, there are many other ways of understanding what Computer Science and programming mean, but just for the sake of this short little essay, I will keep it brief.

Let me know your thoughts.

- Brett Webster


